PATHS[[i+2]] <- arrival_time_estimate(attributes(AA[[i]])$names, start_time)
}
min_TT <- Inf
for (i in 1:length(PATHS)){
if (min_TT > rev(PATHS[[i]]$TIMES)[1]){
min_TT <- rev(PATHS[[i]]$TIMES)[1]
i_min_TT <- i
}
}
paste0("Departure time is at", min_TT)
paste0("Arrival time is at", min_TT)
paste0(paste0("Best route is "), paste(PATHS[[i_min_TT]]$PATH, collapse=' > '))
}
find_best_route(Source="A", Dist="G", start_time = 0)
find_best_route(Source="A", Dist="G", start_time = 0)
find_best_route(Source="A", Dist="G", start_time = 0)
### FIND THE BEST ARRIVAL TIME ###
find_best_route <- function(Source, Dist, start_time=0){
PATHS <- list()
PATHS[[1]] <- walk_through_shortest_path(Source, Dist, start_time)
PATHS[[2]] <- walk_through_unaffected_path(Source, Dist, start_time)
AA <- all_simple_paths(G[[1]], from = Source, to = Dist)
for (i in 1:length(AA)) {
PATHS[[i+2]] <- arrival_time_estimate(attributes(AA[[i]])$names, start_time)
}
min_TT <- Inf
for (i in 1:length(PATHS)){
if (min_TT > rev(PATHS[[i]]$TIMES)[1]){
min_TT <- rev(PATHS[[i]]$TIMES)[1]
i_min_TT <- i
}
}
paste0(paste0("Best route is "), paste(PATHS[[i_min_TT]]$PATH, collapse=' > '))
paste0("Departure time is at", min_TT)
paste0("Arrival time is at", min_TT)
}
find_best_route(Source="A", Dist="G", start_time = 0)
route <- find_best_route(Source="A", Dist="G", start_time = 0)
### FIND THE BEST ARRIVAL TIME ###
find_best_route <- function(Source, Dist, start_time=0){
PATHS <- list()
PATHS[[1]] <- walk_through_shortest_path(Source, Dist, start_time)
PATHS[[2]] <- walk_through_unaffected_path(Source, Dist, start_time)
AA <- all_simple_paths(G[[1]], from = Source, to = Dist)
for (i in 1:length(AA)) {
PATHS[[i+2]] <- arrival_time_estimate(attributes(AA[[i]])$names, start_time)
}
min_TT <- Inf
for (i in 1:length(PATHS)){
if (min_TT > rev(PATHS[[i]]$TIMES)[1]){
min_TT <- rev(PATHS[[i]]$TIMES)[1]
i_min_TT <- i
}
}
out <- as.list("best_route" = PATHS[[i_min_TT]]$PATH , "departure time" = start_time, "arrival time" = min_TT)
return(out)
}
route <- find_best_route(Source="A", Dist="G", start_time = 0)
route <- find_best_route(Source="A", Dist="G", start_time = 0)
out <- list("best_route" = PATHS[[i_min_TT]]$PATH , "departure time" = start_time, "arrival time" = min_TT)
### ESTIMATE ARRIVAL TIME on a PATH ###
arrival_time_estimate <- function(path, start_time=0){
TIMES <- as.numeric()
TIMES[1] = start_time
for (i in 2:length(path)){
ttt <- sprintf("%03d", 10*ceiling(TIMES[i-1]/10))
if (ttt %in% names(M)){
tmp.travel_time <- max(as.numeric(M[[ttt]][path[i-1],path[i]]) , as.numeric(M[[ttt]][path[i],path[i-1]]))
TIMES[i] <- TIMES[i-1] + tmp.travel_time
} else {
TIMES[i:length(path)] <- 1/0
break
}
}
out_df <- data.frame("PATH" = path , "TIMES" = TIMES, stringsAsFactors = FALSE)
return(out_df)
}
### FIND THE BEST ARRIVAL TIME ###
find_best_route <- function(Source, Dist, start_time=0){
PATHS <- list()
PATHS[[1]] <- walk_through_shortest_path(Source, Dist, start_time)
PATHS[[2]] <- walk_through_unaffected_path(Source, Dist, start_time)
AA <- all_simple_paths(G[[1]], from = Source, to = Dist)
for (i in 1:length(AA)) {
PATHS[[i+2]] <- arrival_time_estimate(attributes(AA[[i]])$names, start_time)
}
min_TT <- Inf
for (i in 1:length(PATHS)){
if (min_TT > rev(PATHS[[i]]$TIMES)[1]){
min_TT <- rev(PATHS[[i]]$TIMES)[1]
i_min_TT <- i
}
}
out <- list("best_route" = PATHS[[i_min_TT]]$PATH , "departure time" = start_time, "arrival time" = min_TT)
return(out)
}
route <- find_best_route(Source="A", Dist="G", start_time = 0)
paste0(paste0("Best route is "), paste(PATHS[[i_min_TT]]$PATH, collapse=' > '))
route
route <- find_best_route(Source="A", Dist="G", start_time = 0)
paste0(paste0("Best route is "), paste(route$best_route, collapse=' > '))
paste0("Departure time at T= ", route$`departure time`)
paste0("Arrival time at T= ", route$`arrival time`)
paste0(paste0("Best route is "), paste(route$best_route, collapse=' > ') , '\n'
, "Departure time at T= ", route$`departure time` , '\n'
, "Arrival time at T= ", route$`arrival time`)
route <- find_best_route(Source="A", Dist="G", start_time = 0)
paste0(paste0("Best route is "), paste(route$best_route, collapse=' > '))
paste0("Departure time at T= ", route$`departure time`)
paste0("Arrival time at T= ", route$`arrival time`)
### MAKE PLOTS AND ANNIMATION ####
{
for (i in seq(0,60,10)){
ttt <- sprintf("%03d", i)
png(paste0(foldname,"Graphs/tt_",ttt,".png"))
mygraph_plot(G[[ttt]])
text(0,1.2,paste0("Travel Times at T+",ttt))
Sys.sleep(1)
dev.off()
}
list.files(path = paste0(foldname,"Graphs/"), pattern = "*.png", full.names = T) %>%
map(image_read) %>% # reads each path file
image_join() %>% # joins image
image_animate(fps=1) %>% # animates, can opt for number of loops
image_write(paste0(foldname,"Graphs/Annim.gif")) # write to current dir
}
print(paste0("Best route is "), paste(route$best_route, collapse=' > '))
print(paste0("Best route is ", paste(route$best_route, collapse=' > ')))
print(paste0("Best route is ", paste(route$best_route, collapse=' > '))
paste0("Departure time at T= ", route$`departure time`)
paste0("Arrival time at T= ", route$`arrival time`))
paste0("Arrival time at T= ", route$`arrival time`)
{
route <- find_best_route(Source="A", Dist="G", start_time = 0)
paste0("Best route is ", paste(route$best_route, collapse=' > '))
paste0("Departure time at T= ", route$`departure time`)
paste0("Arrival time at T= ", route$`arrival time`)
}
{
route <- find_best_route(Source="A", Dist="G", start_time = 0)
print(paste0("Best route is ", paste(route$best_route, collapse=' > ')))
print(paste0("Departure time at T= ", route$`departure time`))
print(paste0("Arrival time at T= ", route$`arrival time`))
}
route <- find_best_route(Source="A", Dist="H", start_time = 0)
{
route <- find_best_route(Source="A", Dist="H", start_time = 0)
print(paste0("Best route is ", paste(route$best_route, collapse=' > ')))
print(paste0("Departure time at T= ", route$`departure time`))
print(paste0("Arrival time at T= ", route$`arrival time`))
}
library(igraph)
library(cppRouting)
library(purrr) # for mapping over a function
library(magick) # this is call to animate/read pngs
### ALL FUNCTIONS ###
{
### PLOT GRAPH WITH COLORIZED ROUTES ###
mygraph_plot <- function(ig){
label_TTs <- round(E(ig)$weight, 3)
color.edge <- rep(c("green"),length(label_TTs))
color.edge[label_TTs > 98] <- "red"
plot(ig, edge.label=label_TTs, layout=layout.grid, vertex.label.color= "black", edge.color=color.edge)
}
### FIND THE MINIMUM FORECASTED TT ###
walk_through_shortest_path <- function(Source, Dist, start_time=0){
PATH1 <- as.character()
TIMES1 <- as.numeric()
PATH1[1] <- Source
current_node = Source
t = start_time
i = 1
while (current_node != Dist) {
#  print(paste0("at T=",sprintf("%03d",t)," --- at node=",current_node))
ttt <- sprintf("%03d", 10*ceiling(t/10))
tmp.ig <- G[[ttt]]
tmp.sp <- shortest_paths(tmp.ig, from = current_node, to = Dist)
tmp.path <- attributes(tmp.sp$vpath[[1]])$names
TIMES1[i] <- t
t = t + as.numeric(distances(tmp.ig, v=current_node, to=tmp.path[2]))
i = i+1
PATH1[i] <- tmp.path[2]
current_node <- tmp.path[2]
}
#print(paste0("at T=",sprintf("%03d",t)," --- at node=",current_node))
TIMES1[i] <- t
out_df <- data.frame("PATH" = PATH1 , "TIMES" = TIMES1, stringsAsFactors = FALSE)
return(out_df)
}
#### USE UN-AFFECTED ROUTES ####
walk_through_unaffected_path <- function(Source, Dist, start_time=0){
PATH2 <- as.character()
TIMES2 <- as.numeric()
M_max <- apply(TT.array,c(1,2),max)
tmp.ig <- graph.adjacency(M_max, mode="undirected", weighted=TRUE)
tmp.sp <- shortest_paths(tmp.ig, from = Source, to = Dist)
tmp.path <- attributes(tmp.sp$vpath[[1]])$names
tmp.t <- distances(tmp.ig, v=Source, to=Dist)
TIMES2[1] = start_time
for (i in 2:length(tmp.path)){
TIMES2[i] <- TIMES2[i-1] + as.numeric(distances(tmp.ig, v=tmp.path[i-1], to=tmp.path[i]))
}
PATH2 <- tmp.path
out_df <- data.frame("PATH" = PATH2 , "TIMES" = TIMES2, stringsAsFactors = FALSE)
return(out_df)
}
### ESTIMATE ARRIVAL TIME on a PATH ###
arrival_time_estimate <- function(path, start_time=0){
TIMES <- as.numeric()
TIMES[1] = start_time
for (i in 2:length(path)){
ttt <- sprintf("%03d", 10*ceiling(TIMES[i-1]/10))
if (ttt %in% names(M)){
tmp.travel_time <- max(as.numeric(M[[ttt]][path[i-1],path[i]]) , as.numeric(M[[ttt]][path[i],path[i-1]]))
TIMES[i] <- TIMES[i-1] + tmp.travel_time
} else {
TIMES[i:length(path)] <- 1/0
break
}
}
out_df <- data.frame("PATH" = path , "TIMES" = TIMES, stringsAsFactors = FALSE)
return(out_df)
}
### FIND THE BEST ARRIVAL TIME ###
find_best_route <- function(Source, Dist, start_time=0){
PATHS <- list()
PATHS[[1]] <- walk_through_shortest_path(Source, Dist, start_time)
PATHS[[2]] <- walk_through_unaffected_path(Source, Dist, start_time)
AA <- all_simple_paths(G[[1]], from = Source, to = Dist)
for (i in 1:length(AA)) {
PATHS[[i+2]] <- arrival_time_estimate(attributes(AA[[i]])$names, start_time)
}
min_TT <- Inf
for (i in 1:length(PATHS)){
if (min_TT > rev(PATHS[[i]]$TIMES)[1]){
min_TT <- rev(PATHS[[i]]$TIMES)[1]
i_min_TT <- i
}
}
out <- list("best_route" = PATHS[[i_min_TT]]$PATH , "departure time" = start_time, "arrival time" = min_TT)
return(out)
}
}
### READ DATA ###
{
foldname <- "E:/Google Drive/NCSU-laptop sharing/Research/UrbanFlood-OKN/Dijkstra with Updating Weights/"
#foldname <- "C:/Users/Amir/Google Drive/NCSU-laptop sharing/Research/UrbanFlood-OKN/Dijkstra with Updating Weights/"
M <- list()
G <- list()
for (i in seq(0,60,10)){
ttt <- sprintf("%03d", i)
filename <- paste0(foldname,"Travel_Times_TestCase1/tt_",ttt)
tmp <- read.delim(filename, header = FALSE)
tmp <- as.matrix(tmp)
colnames(tmp) <- LETTERS[seq( from = 1, to = 8)]
rownames(tmp) <- LETTERS[seq( from = 1, to = 8)]
M[[ttt]] <- tmp
G[[ttt]] <- graph.adjacency(M[[ttt]], mode="undirected", weighted=TRUE)
}
TT.array <- array(as.numeric(unlist(M)), dim=c(8,8,7))
rownames(TT.array) <- LETTERS[1:8]
colnames(TT.array) <- LETTERS[1:8]
}
{
route <- find_best_route(Source="A", Dist="H", start_time = 0)
print(paste0("Best route is ", paste(route$best_route, collapse=' > ')))
print(paste0("Departure time at T= ", route$`departure time`))
print(paste0("Arrival time at T= ", route$`arrival time`))
}
{
route <- find_best_route(Source="A", Dist="H", start_time = 10)
print(paste0("Best route is ", paste(route$best_route, collapse=' > ')))
print(paste0("Departure time at T= ", route$`departure time`))
print(paste0("Arrival time at T= ", route$`arrival time`))
}
{
route <- find_best_route(Source="A", Dist="G", start_time = 10)
print(paste0("Best route is ", paste(route$best_route, collapse=' > ')))
print(paste0("Departure time at T= ", route$`departure time`))
print(paste0("Arrival time at T= ", route$`arrival time`))
}
{
route <- find_best_route(Source="A", Dist="G", start_time = 0)
print(paste0("Best route is ", paste(route$best_route, collapse=' > ')))
print(paste0("Departure time at T= ", route$`departure time`))
print(paste0("Arrival time at T= ", route$`arrival time`))
}
walk_through_shortest_path(Source, Dist, start_time)
Source = "A"
Dist = "G"
walk_through_shortest_path(Source, Dist, start_time)
walk_through_shortest_path(Source, Dist, start_time=0)
walk_through_unaffected_path(Source, Dist, start_time=0)
M_max <- apply(TT.array,c(1,2),max)
tmp.ig <- graph.adjacency(M_max, mode="undirected", weighted=TRUE)
mygraph_plot(tmp.ig)
{
route <- find_best_route(Source="A", Dist="G", start_time = 0)
print(paste0("Best route is ", paste(route$best_route, collapse=' > ')))
print(paste0("Departure time at T= ", route$`departure time`))
print(paste0("Arrival time at T= ", route$`arrival time`))
}
### FIND THE BEST ARRIVAL TIME ###
find_best_route <- function(Source, Dist, start_time=0){
PATHS <- list()
PATHS[[1]] <- walk_through_shortest_path(Source, Dist, start_time)
PATHS[[2]] <- walk_through_unaffected_path(Source, Dist, start_time)
AA <- all_simple_paths(G[[1]], from = Source, to = Dist)
for (i in 1:length(AA)) {
PATHS[[i+2]] <- arrival_time_estimate(attributes(AA[[i]])$names, start_time)
}
min_TT <- Inf
for (i in 1:length(PATHS)){
if (min_TT > rev(PATHS[[i]]$TIMES)[1]){
min_TT <- rev(PATHS[[i]]$TIMES)[1]
i_min_TT <- i
}
}
out <- list("best_route" = PATHS[[i_min_TT]]$PATH , "departure time" = start_time, "arrival time" = min_TT)
return(out)
print(paste0("Best route is ", paste(out$best_route, collapse=' > ')))
print(paste0("Departure time at T= ", out$`departure time`))
print(paste0("Arrival time at T= ", out$`arrival time`))
}
route <- find_best_route(Source="A", Dist="G", start_time = 0)
find_best_route(Source="A", Dist="G", start_time = 0)
### FIND THE BEST ARRIVAL TIME ###
find_best_route <- function(Source, Dist, start_time=0){
PATHS <- list()
PATHS[[1]] <- walk_through_shortest_path(Source, Dist, start_time)
PATHS[[2]] <- walk_through_unaffected_path(Source, Dist, start_time)
AA <- all_simple_paths(G[[1]], from = Source, to = Dist)
for (i in 1:length(AA)) {
PATHS[[i+2]] <- arrival_time_estimate(attributes(AA[[i]])$names, start_time)
}
min_TT <- Inf
for (i in 1:length(PATHS)){
if (min_TT > rev(PATHS[[i]]$TIMES)[1]){
min_TT <- rev(PATHS[[i]]$TIMES)[1]
i_min_TT <- i
}
}
out <- list("best_route" = PATHS[[i_min_TT]]$PATH , "departure time" = start_time, "arrival time" = min_TT)
return(out)
message(paste0("Best route is ", paste(out$best_route, collapse=' > ')))
message(paste0("Departure time at T= ", out$`departure time`))
message(paste0("Arrival time at T= ", out$`arrival time`))
}
route <- find_best_route(Source="A", Dist="G", start_time = 0)
find_best_route(Source="A", Dist="G", start_time = 0)
message(paste0("Best route is ", paste(out$best_route, collapse=' > ')))
### FIND THE BEST ARRIVAL TIME ###
find_best_route <- function(Source, Dist, start_time=0){
PATHS <- list()
PATHS[[1]] <- walk_through_shortest_path(Source, Dist, start_time)
PATHS[[2]] <- walk_through_unaffected_path(Source, Dist, start_time)
AA <- all_simple_paths(G[[1]], from = Source, to = Dist)
for (i in 1:length(AA)) {
PATHS[[i+2]] <- arrival_time_estimate(attributes(AA[[i]])$names, start_time)
}
min_TT <- Inf
for (i in 1:length(PATHS)){
if (min_TT > rev(PATHS[[i]]$TIMES)[1]){
min_TT <- rev(PATHS[[i]]$TIMES)[1]
i_min_TT <- i
}
}
out <- list("best_route" = PATHS[[i_min_TT]]$PATH , "departure time" = start_time, "arrival time" = min_TT)
message(paste0("Best route is ", paste(out$best_route, collapse=' > ')))
message(paste0("Departure time at T= ", out$`departure time`))
message(paste0("Arrival time at T= ", out$`arrival time`))
return(out)
}
find_best_route(Source="A", Dist="G", start_time = 0)
route <- find_best_route(Source="A", Dist="G", start_time = 0)
shiny::runApp('E:/Google Drive/NCSU-laptop sharing/Research/UrbanFlood-OKN/NWM Uncertainty Quantification/NWM_Assessment_ShinyApp')
runApp('E:/Google Drive/NCSU-laptop sharing/Research/UrbanFlood-OKN/NWM Uncertainty Quantification/NWM_Assessment_ShinyApp')
runApp('E:/Google Drive/NCSU-laptop sharing/Research/UrbanFlood-OKN/NWM Uncertainty Quantification/Regional_Assessment_NWM')
runApp('E:/Google Drive/NCSU-laptop sharing/Research/UrbanFlood-OKN/NWM Uncertainty Quantification/NWM_Assessment_ShinyApp')
install.packages("dygraphs")
library(dygraphs)
library(plotly)
install.packages("plotly")
library(plotly)
?plot_ly
today
plot_ly(x = 1:10, y = 1:10, color = I("red"), marker = list(color = "blue"))
setwd("E:/Google Drive/NCSU-laptop sharing/Research/UrbanFlood-OKN/NWM Uncertainty Quantification/Regional_Assessment_NWM")
metrics.overall <- read.table("./AppDATA/Verification_Metrics_overall_v2", sep=",", header = TRUE,
colClasses = c("siteID"="character"))
colnames(metrics.overall)[-1] <- paste0(colnames(metrics.overall)[-1],"_overall")
metrics.seasonal <- read.table("./AppDATA/Verification_Metrics_seasonal_v2", sep=",", header = TRUE,
colClasses = c("siteID"="character"))
metrics.monthly <- read.table("./AppDATA/Verification_Metrics_monthly_v2", sep=",", header = TRUE,
colClasses = c("siteID"="character"))
metrics.all <- cbind(metrics.overall, metrics.seasonal[,-1], metrics.monthly[,-1])
is.na(metrics.all) <- sapply(metrics.all, is.infinite)
basin_layer <- shapefile(paste0("AppDATA/stations_info.shp"))
basin_layer.info <- read.table("AppDATA/info_stations.txt", sep=",", header=TRUE,
colClasses = c("siteID"="character"))
list.units <- c("miu_obs" = "[cms]", "sigma_obs" = "[cms]", "miu_est" = "[cms]", "sigma_est" = "[cms]",
"MSE"="", "KGE"="", "NSE"="", "NSE_A"="", "NSE_B"="", "NSE_C"="")
list.assessment_subnames <- list("Annual" = "overall",
"Seasonal" = c("winter","spring","summer","fall"),
"Monthly" = month.abb)
X = basin_layer.info[,"AI"]
Y = metrics.all[,"miu_obs_overall"]
metrics.overall <- read.table("./AppDATA/Verification_Metrics_overall_v2", sep=",", header = TRUE,
colClasses = c("siteID"="character"))
plot_ly(X,Y, color = basin_layer.info[tmp.ind_RA(),"CLASS"], type = "scatter")
as.data.frame(X,Y)
aa <- as.data.frame(X,Y)
View(aa)
aa <- as.data.frame("X"=X,"Y"=Y)
X
aa <- data.frame("X"=X,"Y"=Y)
plot_ly(data.frame("X"=X,"Y"=Y), color = basin_layer.info[tmp.ind_RA(),"CLASS"], type = "scatter")
plot_ly(data.frame("X"=X,"Y"=Y), color = basin_layer.info[,"CLASS"], type = "scatter")
plot_ly(data.frame("X"=X,"Y"=Y), color = basin_layer.info[,"CLASS"])
plot_ly(data.frame("X"=X,"Y"=Y))
?plot_ly
aa <- data.frame("X"=X,"Y"=Y)
plot_ly(type = 'scatter',  mode='markers', data = aa, x = ~X.,
y = ~Y, marker=list(size=3, color=~CLASS,
colorbar=list(title='Ratio Area \n barren/vegetated'), colorscale='Rainbow',
reversescale =T ))
aa$X
plot_ly(type = 'scatter',  mode='markers', data = aa, x = ~X.,
y = ~Y)
plot_ly(type = 'scatter',  mode='markers', data = aa, x = ~X, y = ~Y)
aa <- data.frame("X"=X,"Y"=Y,"color"=basin_layer.info[,"CLASS"])
View(aa)
tmp.dataly <- data.frame("X"=X,"Y"=Y,"color"=basin_layer.info[,"CLASS"])
plot_ly(type = 'scatter',  mode='markers', tmp.dataly,
x = ~x, y = ~y, marker=list(size=2, color=~color,
colorbar=list(title='Basin Class'),
colorscale='Rainbow', reversescale =T ))
tmp.dataly <- data.frame("x"=X,"y"=Y,"color"=basin_layer.info[,"CLASS"])
plot_ly(type = 'scatter',  mode='markers', tmp.dataly,
x = ~x, y = ~y, marker=list(size=2, color=~color,
colorbar=list(title='Basin Class'),
colorscale='Rainbow', reversescale =T ))
plot_ly(type = 'scatter',  mode='markers', tmp.dataly,
x = ~x, y = ~y, marker=list(size=4, color=~color,
colorbar=list(title='Basin Class'),
colorscale='Rainbow', reversescale =T ))
plot_ly(type = 'scatter',  mode='markers', tmp.dataly,
x = ~x, y = ~y, color=~color)
runApp()
?renderPlotly
runApp()
runApp()
?plot_ly
?plotlyOutput
runApp()
View(basin_layer.info)
?plot_ly
?layout
?plot_ly
runApp()
runApp()
runApp()
runApp()
runApp()
library(raster)
load("C:/Users/amazroo/Desktop/shp_basins/basins.shp")
shapefile("C:/Users/amazroo/Desktop/shp_basins/basins.shp")
dd <- shapefile("C:/Users/amazroo/Desktop/shp_basins/basins.shp")
a <- dd$NID_str
dim(a)
nrow(a)
length(a)
View(dd)
?merge
dd$data
df <- as.data.frame(dd)
View(df)
merge(basin_layer.info, df[,-"class"], by="siteID")
merge(basin_layer.info, df[,-3], by="siteID")
aa <- merge(basin_layer.info, df[,-3], by="siteID")
View(aa)
aa <- merge(basin_layer.info, df[,-3], by="siteID", all.x=TRUE)
View(aa)
write.table(aa, "./AppDATA/info_stations.txt", sep=",", row.names = FALSE, col.names = TRUE)
metrics.overall <- read.table("./AppDATA/Verification_Metrics_overall_v2", sep=",", header = TRUE,
colClasses = c("siteID"="character"))
colnames(metrics.overall)[-1] <- paste0(colnames(metrics.overall)[-1],"_overall")
metrics.seasonal <- read.table("./AppDATA/Verification_Metrics_seasonal_v2", sep=",", header = TRUE,
colClasses = c("siteID"="character"))
metrics.monthly <- read.table("./AppDATA/Verification_Metrics_monthly_v2", sep=",", header = TRUE,
colClasses = c("siteID"="character"))
metrics.all <- cbind(metrics.overall, metrics.seasonal[,-1], metrics.monthly[,-1])
is.na(metrics.all) <- sapply(metrics.all, is.infinite)
basin_layer <- shapefile(paste0("AppDATA/stations_info.shp"))
basin_layer.info <- read.table("AppDATA/info_stations.txt", sep=",", header=TRUE,
colClasses = c("siteID"="character"))
list.units <- c("miu_obs" = "[cms]", "sigma_obs" = "[cms]", "miu_est" = "[cms]", "sigma_est" = "[cms]",
"MSE"="", "KGE"="", "NSE"="", "NSE_A"="", "NSE_B"="", "NSE_C"="")
list.assessment_subnames <- list("Annual" = "overall",
"Seasonal" = c("winter","spring","summer","fall"),
"Monthly" = month.abb)
basin_layer.info$dams
colnames(basin_layer.info)
runApp()
image("./Documentation/NSE.png")
runApp()
runApp()
runApp()
image("./Documentation/Capture1.JPG
runApp()
runApp()
runApp()
